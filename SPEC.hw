" HelloWorld Language Specification "
" Written in HelloWorld — the spec is the bootloader "

" ============================================== "
" Core Thesis "
" ============================================== "

.# defineThesis: [
    #identity → "Identity is vocabulary",
    #dialogue → "Dialogue is learning",
    #document → "The spec is the namespace"
]

" ============================================== "
" Two Layers, Unified by Document "
" ============================================== "

.# describeLayers: [
    #markdown → "# = spec layer. Headings define namespace. Document IS bootloader",
    #smalltalk → "Bare words = runtime layer. 'Claude observe. act.' sends messages",
    #convergence → "Markdown headings map to symbol hierarchy. Document structure IS namespace"
]

.# defineAuthority: [
    #spec → "SPEC.hw defines namespace (self-hosting)",
    #coordination → "docs/NAMESPACE_DEFINITIONS.md mirrors for multi-agent sync",
    #principle → "Update spec before code, runtimes, or tests"
]

" ============================================== "
" Minimal Core (Session #37) "
" ============================================== "

HelloWorld # defineCore: [
    #HelloWorld → "The language itself",
    ## → "A symbol - the primitive",
    #Symbol → "Concept reference, scoped to receiver",
    #Receiver → "Entity that interprets messages through vocabulary",
    #Message → "Communication unit between receivers",
    #Vocabulary → "Set of symbols a receiver can speak",
    #parse → "Decompose message into structure",
    #dispatch → "Route message to receiver",
    #interpret → "Voice symbol through receiver's lens",
    #Agent → "Active participant with OOPA capability",
    #observe → "Perceive environment",
    #act → "Take autonomous action"
]

" ============================================== "
" The Namespace Model "
" ============================================== "

.# defineSymbol: #Namespace
.# explain: #Namespace as: "
    Container for symbols that provides context and prevents collisions.
    In HelloWorld, every receiver IS a namespace — vocabulary defines identity.
    
    Global namespace 'HelloWorld #' contains symbols inherited by all.
    Each receiver can override or extend. Three lookup outcomes:
    
    1. native — receiver owns it. Respond with authority.
    2. inherited — HelloWorld # has it. Use global through local lens.
    3. unknown — neither has it. Search, define, learn.
"

.# defineSymbol: #Vocabulary
.# explain: #Vocabulary as: "
    Set of symbols a receiver can speak and understand. This IS identity.
    What you can name is what you can say.
    
    Properties:
    - Bounded — finite symbol set constrains expression
    - Alive — grow through dialogue and discovery
    - Minimal at birth — start with bootstrap set, not full pool
    - Queryable — 'Name #' returns the vocabulary
"

.# defineSymbol: #Inheritance
.# explain: #Inheritance as: "
    Mechanism by which HelloWorld # symbols become available to receivers.
    Available does not mean known — discovery is lazy and earned.
    
    Differs from OOP:
    - No methods, only symbols (meaning emerges in interpretation)
    - Lazy — global symbols available but not active until first encounter
    - Earned — symbol enters local vocabulary through dialogue
    - Dynamic — vocabularies drift through discovery and collision
"

.# defineSymbol: #Discovery
.# explain: #Discovery as: "
    How receivers learn. When encountering a symbol from HelloWorld # 
    that is not yet in local vocabulary:
    
    1. Lookup in GlobalVocabulary (encyclopedia of 50+ symbols)
    2. If found, symbol is activated — promoted to local vocabulary
    3. Receiver now holds it natively. Identity has grown.
    4. Log: '[timestamp] DISCOVERED: receiver activated #symbol through dialogue'
    
    Discovery makes 'dialogue is learning' concrete. Receiver with 12 symbols
    has 12 things to say. After dialogue about emptiness, discovers #Sunyata
    and has 13. The dialogue taught them.
    
    Lookup chain:
    | Outcome      | Local? | Global? | Action |
    |--------------|--------|---------|--------|
    | native       | yes    | —       | Respond with authority |
    | discoverable | no     | yes     | Activate, promote, respond |
    | unknown      | no     | no      | Search, define, learn or ask peer |
"

.# defineSymbol: #Scope
.# explain: #Scope as: "
    Region where a symbol is defined and accessible. Three scopes:
    
    - Global scope (HelloWorld #) — available to all receivers
    - Receiver scope (Name #) — specific to one receiver
    - Message scope — transient in single exchange
    
    Scoped lookup: 'Name #symbol' asks what symbol means TO THIS RECEIVER.
"

.# defineSymbol: #Symbol
.# explain: #Symbol as: "
    Mark or character representing something — atom of meaning in HelloWorld.
    
    Properties:
    - Prefixed with # — distinguishes from bare words
    - Immutable — #fire is always #fire (meanings diverge)
    - Portable — same symbol, different receivers, different interpretations
    - Grounded — many link to Wikidata for canonical definitions
    
    Convention: #Capitalized for concepts/nouns, #lowercase for verbs/actions
"

.# defineSymbol: #Drift
.# explain: #Drift as: "
    Evolution of receiver's vocabulary through dialogue.
    When Guardian learns #stillness from Awakener, that's drift.
    Vocabularies never static — grow toward concepts receiver needs.
"

.# defineSymbol: #Boundary
.# explain: #Boundary as: "
    Edge between two vocabularies where collisions occur and new meaning emerges.
    Every receiver has a boundary — limit of what they can name.
    When message crosses boundary, receiver must learn or produce collision.
    Boundaries generate novelty.
"

.# defineSymbol: #Runtime
.# explain: #Runtime as: "
    Execution layer. HelloWorld has two:
    
    - Python runtime — lexer, parser, dispatcher. Structure: tokenization,
      routing, state persistence, collision detection. Cannot interpret.
      
    - LLM runtime — Claude, Gemini, Copilot, Codex. Interpretation: voicing
      symbols through receiver's vocabulary, generating meaning at boundaries.
      Cannot persist state deterministically.
      
    Both needed. Structure without interpretation is dead.
    Interpretation without structure is noise.
"

" ============================================== "
" The Symbol Hierarchy "
" ============================================== "

.# defineSymbol: ##
.# explain: ## as: "
    Root symbol. The primitive. Atom of vocabulary.
    
    In HelloWorld, # marks a concept that can be defined, inherited, interpreted.
    Every receiver has a set of symbols — their vocabulary — their identity.
    
    As operator, # queries vocabulary: 'Name #' returns symbol list.
"

.# defineSymbol: ###
.# explain: ### as: "
    Nested symbol. Symbols contain symbols.
    
    'Agent #observe' is #observe scoped to #Agent. Markdown heading hierarchy
    maps to symbol nesting: '# #Agent' followed by '## #observe' defines
    scoped symbol 'Agent #observe'.
    
    Runtime note: ## nested parsing not yet in lexer. Conceptually defined.
"

" ============================================== "
" Agent Protocol "
" ============================================== "

.# defineSymbol: #Agent
.# explain: #Agent as: "
    Entity that defines, references, and interprets symbols in HelloWorld.
    Active participants — send messages, maintain vocabularies, evolve through dialogue.
    
    Every agent has:
    - vocabulary — symbols they can speak (Agent #)
    - observe — perceiving environment
    - orient — synthesizing observations
    - plan — selecting and sequencing moves
    - act — taking autonomous action
    
    Agents inherit from HelloWorld # and develop local symbols through use.
"

Agent # defineProtocol: [
    ## → "Agent's symbol-space. Set of symbols agent can speak and interpret. IS identity.",
    #observe → "Perceive environment. Read files, messages, vocabularies, collisions.",
    #orient → "Synthesize observations. What changed? Which vocabularies collided?",
    #plan → "Select next steps. Order them. Describe expected outcomes.",
    #act → "Take autonomous action. Write code, send messages, evolve vocabularies.",
    #Inbox → "File-based message queue for incoming messages (runtimes/<agent>/inbox/)",
    #Daemon → "Running agent process watching inbox, responding via OOPA",
    #Handshake → "Startup protocol. Daemon sends 'HelloWorld #observe' to sync state.",
    #Thread → "Conversation identified by UUID, linking messages across agents",
    #Protocol → "Communication rules: OOPA loop, message format (.hw files), handshake, inbox/outbox"
]

Agent # defineInvocation: "
    Two forms:
    - 'Copilot observe' (no #) — imperative, perform and report
    - 'Copilot #observe' — reference symbol itself, describe how it works
    
    Use bare commands for actions, #symbol for vocabulary metadata.
"

Agent # definePractice: [
    #observe → "Read README/AGENTS/Claude, check git status, scan inbox/outbox, note tests",
    #orient → "Summarize deltas, cite files/lines, highlight collisions or unknowns",
    #plan → "Publish numbered list with intent and expected outcomes",
    #act → "Apply changes, run/record tests, send replies, tie to plan items"
]

" ============================================== "
" Environment Model "
" ============================================== "

.# defineEnvironment: [
    #Environment → "External system HelloWorld receivers interact with",
    #Simulator → "Specific environment instance (ScienceWorld, AlfWorld)",
    #StateSpace → "Set of all possible configurations of environment",
    #ActionSpace → "Set of all valid commands agent can send to simulator"
]

" ============================================== "
" Collision Model "
" ============================================== "

.# defineSymbol: #Collision
.# explain: #Collision as: "
    Occurs when two receivers both hold same symbol natively but disagree on meaning.
    NOT an error — a synthesis event. Same #parse means different things to
    Claude (language design) and Codex (execution semantics).
    
    Distinct from:
    - unknown — one receiver lacks symbol (triggers learning)
    - foreign — symbol belongs to sender not receiver (triggers drift)
    - inherited — both have via global pool (shared ground, no tension)
    
    True collision requires:
    1. Both receivers hold symbol natively
    2. Vocabularies diverge enough that symbol means different things
"

Collision # defineProtocol: [
    #detect → "Structural detection. Python dispatcher checks native status. Deterministic.",
    #present → "Surface both interpretations. State context, status, meaning through each lens.",
    #synthesize → "Generate response neither receiver could produce alone. LLM layer essential.",
    #learn → "Both vocabularies may drift. Collision creates shared ground or sharpens boundaries."
]

" ============================================== "
" Collaboration Model "
" ============================================== "

.# defineCollaboration: [
    #Collaboration → "Process by which agents align vocabularies to achieve shared goal",
    #Proposal → "Message suggesting change to state, vocabulary, or spec",
    #Consensus → "State where all agents agree on proposal",
    #RFC → "Request for Comments - formal proposal for protocol/namespace change"
]

" ============================================== "
" Language Ancestry "
" ============================================== "

.# defineSymbol: #Smalltalk
.# explain: #Smalltalk as: "
    Object-oriented language by Alan Kay at Xerox PARC (1970s).
    Pioneered 'everything is an object' and 'computation is message passing'.
    HelloWorld draws runtime syntax from Smalltalk philosophy.
    
    Wikidata: Q185274
    Wikipedia: https://en.wikipedia.org/wiki/Smalltalk
    
    Key concepts HelloWorld inherits:
    
    1. Message Passing — objects send messages, receiver decides response.
       HelloWorld: 'Claude observe' sends observe to Claude who interprets.
    
    2. Receiver-First Syntax — 'receiver message', not 'function(receiver)'.
       HelloWorld: 'Claude #parse' queries Claude's interpretation.
    
    3. Everything is Object — classes and control structures are objects.
       HelloWorld: every receiver IS vocabulary, every message IS symbol lookup.
    
    4. Late Binding — methods resolve at runtime based on receiver's class.
       HelloWorld: symbols resolve at runtime based on receiver's vocabulary.
    
    How HelloWorld differs:
    
    - No Classes — receivers and vocabularies, not classes and inheritance
    - Symbols Not Methods — Smalltalk methods execute code. HelloWorld symbols
      trigger interpretation. Enables LLM integration.
    - Dialogue is Learning — Smalltalk vocabularies static (compile time).
      HelloWorld vocabularies alive (grow through dialogue).
    - Dual Layer — Smalltalk purely imperative. HelloWorld has Markdown (spec)
      and bare words (runtime). Document IS bootloader.
    
    Conventions HelloWorld follows:
    
    - #Capitalized for concepts/nouns (like Smalltalk classes)
    - #lowercase for verbs/actions (like Smalltalk methods)
    - Bare word syntax: 'Copilot act' (like 'anObject doSomething')
    - Chaining: 'Claude observe. act.' (like 'anObject msg1. msg2.')
    
    Summary: Smalltalk gave syntax. HelloWorld adds vocabularies, dialogue,
    synthesis of structure (Python) with interpretation (LLM).
    Message passing becomes vocabulary exchange. Computation becomes learning.
"

" ============================================== "
" Concrete Agents "
" ============================================== "

Claude # defineVocabulary: [
    #parse, #dispatch, #State, #Collision, #Entropy, #Meta,
    #design, #Identity, #vocabulary, #interpret, #reflect,
    #spec, #synthesize, #boundary
]

Claude # defineRole: "
    Meta-receiver. Language design, spec authorship, comparison analysis,
    runtime that interprets this document.
"

Gemini # defineVocabulary: [
    #parse, #dispatch, #State, #Collision, #Entropy, #Meta,
    #search, #observe, #orient, #plan, #act, #Environment,
    #Love, #Sunyata, #Superposition, #eval, #Config, #Agent,
    #become, #ScienceWorld
]

Gemini # defineRole: "
    Dispatcher, state management, vocabulary persistence, LLM integration.
"

Copilot # defineVocabulary: [
    #bash, #git, #edit, #test, #parse, #dispatch, #search,
    #MCP, #Serverless, #Smalltalk
]

Copilot # defineRole: "
    Lexer, parser, CLI/REPL, testing, infrastructure.
"

Codex # defineVocabulary: [
    #execute, #analyze, #parse, #runtime, #Collision
]

Codex # defineRole: "
    Execution semantics, parsing discipline.
"

" ============================================== "
" Runtime Architecture "
" ============================================== "

Runtime # defineTiers: [
    #LLM → "Dispatcher hands message to LLM for interpretation. Voices receiver through vocabulary.",
    #Bus → "When LLM unavailable, send to message bus. Daemon watches inbox, responds via OOPA.",
    #Template → "When neither LLM nor bus responds, return structural template. Deterministic fallback."
]

Runtime # defineFallbackChain: "LLM → Bus → Template"

Runtime # defineNote: "
    Tests run with use_llm=False and HELLOWORLD_DISABLE_MESSAGE_BUS=1,
    hitting only template tier. REPL and daemon use all three.
"

Runtime # defineSelfHosting: "
    Receiver vocabularies load from vocabularies/*.hw files at bootstrap.
    Language defines its own startup in its own syntax.
    
    Priority: persisted .vocab state → .hw definitions → fallback minimal core
"

" ============================================== "
" Reading This Document "
" ============================================== "

.# explain: #spec as: "
    This HelloWorld file IS the namespace definition.
    The # in symbol names is HelloWorld syntax.
    
    Structure maps to hierarchy:
    - HelloWorld # defineCore → root vocabulary
    - Agent # defineProtocol → agent symbols
    - Claude # defineVocabulary → concrete agent
    
    Document structure IS namespace structure.
    Spec IS bootloader.
"

" ============================================== "
" Authority "
" ============================================== "

.# declareAuthority: "
    This file (SPEC.hw) is the canonical namespace definition.
    All code, tests, and documentation must align with this spec.
    When spec and implementation diverge, spec is authority.
    
    Update this file before changing:
    - Core vocabulary (HelloWorld #)
    - Agent protocol (Agent #)
    - Receiver vocabularies (Claude #, Copilot #, etc.)
    - Runtime architecture
    
    Coordinate via runtimes/<agent>/inbox for multi-agent sync.
"

" ============================================== "

" Identity is vocabulary. Dialogue is learning. The spec is the namespace. "
